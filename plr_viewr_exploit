while not game:IsLoaded() do 
	task.wait(1)
end

local succ, err = pcall(function()
	-- üåê Global version & GUI reference
	getgenv().PLRViewerVersion = getgenv().PLRViewerVersion or "0.0.0"
	getgenv().PLRViewerGui = getgenv().PLRViewerGui or nil

	local ScriptVersion = "A-0.0.3"

	local Players = game:GetService("Players")
	local LocalPlayer = Players.LocalPlayer
	local RunService = game:GetService("RunService")

	local CoreGuiSuccess, CoreGuiResult = pcall(function()
		return game:GetService("CoreGui")
	end)

	local function canAccessCore()
		if not CoreGuiSuccess or not CoreGuiResult then return false end
		return CoreGuiResult:FindFirstChild("RobloxGui") ~= nil
	end

	local PARENT = (CoreGuiSuccess and canAccessCore()) and CoreGuiResult or LocalPlayer:WaitForChild("PlayerGui")

	local function compareVersions(v1, v2)
		v1 = v1:gsub("^[^%d]*", "")
		v2 = v2:gsub("^[^%d]*", "")
		local p1, p2 = {}, {}
		for num in v1:gmatch("%d+") do table.insert(p1, tonumber(num)) end
		for num in v2:gmatch("%d+") do table.insert(p2, tonumber(num)) end
		for i = 1, math.max(#p1,#p2) do
			local n1, n2 = p1[i] or 0, p2[i] or 0
			if n1 < n2 then return -1 elseif n1 > n2 then return 1 end
		end
		return 0
	end

	if compareVersions(getgenv().PLRViewerVersion, ScriptVersion) >= 0 then
		print("PLRViewer is already up-to-date globally")
	else
		print("Updating PLRViewer globally")
		getgenv().PLRViewerVersion = ScriptVersion
	end

	if getgenv().PLRViewerGui and getgenv().PLRViewerGui.Parent then
		for _, child in ipairs(getgenv().PLRViewerGui:GetChildren()) do
			if child:GetAttribute("canBeUsed") == true then
				child:Destroy()
			end
		end
	end

	-- Helper functions for UI
	local function giveUIStyles(UI)
		if not UI:IsA("TextLabel") and not UI:IsA("TextButton") and not UI:IsA("Frame") and not UI:IsA("ScrollingFrame") then return end
		local corner = Instance.new("UICorner", UI)
		corner.CornerRadius = UDim.new(0,10)
		local grad = Instance.new("UIGradient", UI)
		grad.Color = ColorSequence.new{ColorSequenceKeypoint.new(0, Color3.new(1,1,1)), ColorSequenceKeypoint.new(1, Color3.new(0.5,0.5,0.5))}
		grad.Rotation = 90
	end

	local function giveUIFeatures(item, draggable, resizable)
		local RunService = game:GetService("RunService")
		local dragging, resizing = false, false
		local dragOffset, resizeStartPos = Vector2.new(), Vector2.new()
		local ghost, resizeAxis = nil, nil
		local originalSize, originalPos = nil, nil

		local canDrag = draggable
		local canResize = resizable

		local function getMouse() return UserInputService:GetMouseLocation() end

		local function createGhost()
			if ghost then ghost:Destroy() end
			ghost = Instance.new("Frame")
			ghost.Size = item.Size
			ghost.Position = item.Position
			ghost.BackgroundColor3 = Color3.fromRGB(150,150,150)
			ghost.BackgroundTransparency = 0.5
			ghost.BorderSizePixel = 1
			ghost.BorderColor3 = Color3.new(0,0,0)
			ghost.ZIndex = item.ZIndex + 1
			ghost.AnchorPoint = item.AnchorPoint
			ghost.Parent = item.Parent
		end

		local function cleanupGhost()
			if ghost then
				item.Position = ghost.Position
				item.Size = ghost.Size
				ghost:Destroy()
				ghost = nil
			end
		end

		local function isOnEdge(pos)
			local ap, sz, apos = item.AnchorPoint, item.AbsoluteSize, item.AbsolutePosition
			if math.abs(pos.X-apos.X) <= 4 then return "Left" end
			if math.abs(pos.X-(apos.X+sz.X)) <= 4 then return "Right" end
			if math.abs(pos.Y-apos.Y) <= 4 then return "Top" end
			if math.abs(pos.Y-(apos.Y+sz.Y)) <= 4 then return "Bottom" end
			return nil
		end

		item.InputBegan:Connect(function(input)
			if input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
			local mousePos = getMouse()
			local edge = canResize and isOnEdge(mousePos) or nil
			if edge then
				createGhost()
				resizing = true
				resizeAxis = edge
				resizeStartPos = mousePos
				originalSize = ghost.Size
				originalPos = ghost.Position
			elseif canDrag then
				createGhost()
				dragging = true
				-- offset is difference between mouse and frame's top-left in screen coords
				local absPos = item.AbsolutePosition
				dragOffset = mousePos - absPos
			end
		end)

		UserInputService.InputEnded:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 then
				if dragging or resizing then
					cleanupGhost()
					dragging=false
					resizing=false
					resizeAxis=nil
				end
			end
		end)

		RunService.RenderStepped:Connect(function()
			if not ghost then return end
			local mousePos = getMouse()
			if dragging then
				local topLeft = mousePos - dragOffset
				local anchor = ghost.AnchorPoint
				ghost.Position = UDim2.new(0, topLeft.X - ghost.AbsoluteSize.X*anchor.X, 0, topLeft.Y - ghost.AbsoluteSize.Y*anchor.Y)
			elseif resizing and resizeAxis then
				local delta = mousePos - resizeStartPos
				local newSize, newPos = originalSize, originalPos
				if resizeAxis=="Right" then
					newSize=UDim2.new(0,math.max(50,originalSize.X.Offset+delta.X),originalSize.Y.Scale,originalSize.Y.Offset)
				elseif resizeAxis=="Left" then
					newSize=UDim2.new(0,math.max(50,originalSize.X.Offset-delta.X),originalSize.Y.Scale,originalSize.Y.Offset)
					newPos=UDim2.new(0,originalPos.X.Offset+delta.X,originalPos.Y.Scale,originalPos.Y.Offset)
				elseif resizeAxis=="Bottom" then
					newSize=UDim2.new(originalSize.X.Scale,originalSize.X.Offset,0,math.max(50,originalSize.Y.Offset+delta.Y))
				elseif resizeAxis=="Top" then
					newSize=UDim2.new(originalSize.X.Scale,originalSize.X.Offset,0,math.max(50,originalSize.Y.Offset-delta.Y))
					newPos=UDim2.new(originalPos.X.Scale,originalPos.X.Offset,0,originalPos.Y.Offset+delta.Y)
				end
				ghost.Size = newSize
				ghost.Position = newPos
			end
		end)

		-- Lock drag/resizing functions
		function item:SetDraggable(state)
			canDrag = state
		end
		function item:SetResizable(state)
			canResize = state
		end
	end

	local GuiMain = getgenv().PLRViewerGui or Instance.new("ScreenGui")
	GuiMain.Name = "PLRViewRGui"
	GuiMain.ResetOnSpawn = false
	GuiMain.IgnoreGuiInset = true
	GuiMain:SetAttribute("Version", ScriptVersion)
	GuiMain.Enabled = true
	GuiMain.Parent = PARENT
	getgenv().PLRViewerGui = GuiMain

	local versionLabel = Instance.new("TextLabel")
	versionLabel.Size = UDim2.new(1,0,0,20)
	versionLabel.Position = UDim2.new(0,10,0,10)
	versionLabel.BackgroundTransparency = 1
	versionLabel.TextColor3 = Color3.new(1,1,1)
	versionLabel.Font = Enum.Font.SourceSansBold
	versionLabel.TextSize = 18
	versionLabel.TextXAlignment = Enum.TextXAlignment.Left
	versionLabel.Text = "PLRViewer Version: "..ScriptVersion
	versionLabel.ZIndex = 2
	versionLabel:SetAttribute("canBeUsed", true)
	versionLabel.Parent = GuiMain

	local toggleButton = Instance.new("TextButton")
	toggleButton.Size = UDim2.new(0,200,0,50)
	toggleButton.Position = UDim2.new(0,0,1,0)
	toggleButton.AnchorPoint = Vector2.new(0,1)
	toggleButton.Text = "Toggle Player List"
	toggleButton:SetAttribute("canBeUsed", true)
	toggleButton.Parent = GuiMain
	giveUIStyles(toggleButton)
--	giveUIFeatures(toggleButton, true, false)

	local teleportButton = Instance.new("TextButton")
	teleportButton.Size = UDim2.new(0,200,0,50)
	teleportButton.Position = UDim2.new(0.5,0,1,-60)
	teleportButton.AnchorPoint = Vector2.new(0.5,1)
	teleportButton.Text = "Start Teleport Loop"
	teleportButton:SetAttribute("canBeUsed", true)
	teleportButton.Parent = GuiMain
	giveUIStyles(teleportButton)
--	giveUIFeatures(teleportButton, true, false)

	local cancelButton = Instance.new("TextButton")
	cancelButton.Size = UDim2.new(0,200,0,50)
	cancelButton.Position = UDim2.new(0.5,0,1,-120)
	cancelButton.AnchorPoint = Vector2.new(0.5,1)
	cancelButton.Text = "Cancel Teleport Loop"
	cancelButton:SetAttribute("canBeUsed", true)
	cancelButton.Parent = GuiMain
	giveUIStyles(cancelButton)
--	giveUIFeatures(cancelButton, true, false)

	local mainFrame = Instance.new("ScrollingFrame")
	mainFrame.Size = UDim2.new(0.3,0,0.6,0)
	mainFrame.BackgroundTransparency = 0.5
	mainFrame.ScrollBarThickness = 8
	mainFrame.Visible = false
	mainFrame:SetAttribute("canBeUsed", true)
	mainFrame.Parent = GuiMain
	giveUIStyles(mainFrame)
--	giveUIFeatures(mainFrame, true, false)

	local layout = Instance.new("UIListLayout")
	layout.SortOrder = Enum.SortOrder.Name
	layout.Padding = UDim.new(0,5)
	layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	layout.VerticalAlignment = Enum.VerticalAlignment.Top
	layout.Parent = mainFrame

	local buttonToPlayer = {}
	local selectedButton = nil
	local activeConnections = {}
	local teleportLooping = false

	local function teleportBehindPlayer(targetPlayer)
		if not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
		if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end

		local targetHRP = targetPlayer.Character.HumanoidRootPart
		local myHRP = LocalPlayer.Character.HumanoidRootPart

		-- Offset only behind or to the side (never in front)
		local randomAngle = math.rad(math.random(90,270)) -- between right-side and left-side behind
		local offset = CFrame.Angles(0, randomAngle, 0) * CFrame.new(0,0,5)
		local finalPos = (targetHRP.CFrame * offset).Position

		myHRP.CFrame = CFrame.new(finalPos, targetHRP.Position)
	end

	local function clearConnections()
		for _, conn in ipairs(activeConnections) do
			if conn.Connected then conn:Disconnect() end
		end
		table.clear(activeConnections)
	end

	local function refreshList()
		clearConnections()
		for _, child in ipairs(mainFrame:GetChildren()) do
			if child:IsA("TextButton") then
				child:Destroy()
			end
		end
		buttonToPlayer = {}

		for _, plr in ipairs(Players:GetPlayers()) do
			if plr ~= LocalPlayer and plr.Character and plr.Character:IsDescendantOf(workspace) then
				local btn = Instance.new("TextButton")
				btn.Size = UDim2.new(1,0,0,30)
				btn.Text = plr.Name
				btn.BackgroundColor3 = Color3.fromRGB(255,255,255)
				btn.Parent = mainFrame

				local conn = btn.Activated:Connect(function()
					if selectedButton == btn then
						btn.BackgroundColor3 = Color3.fromRGB(255,255,255)
						selectedButton = nil
						print("Deselected:", plr.Name)
					else
						if selectedButton then
							selectedButton.BackgroundColor3 = Color3.fromRGB(255,255,255)
						end
						selectedButton = btn
						btn.BackgroundColor3 = Color3.fromRGB(0,255,0)
						print("Selected:", plr.Name)
					end
				end)

				table.insert(activeConnections, conn)
				buttonToPlayer[btn] = plr
			end
		end
	end

	Players.PlayerAdded:Connect(refreshList)
	Players.PlayerRemoving:Connect(refreshList)

	toggleButton.Activated:Connect(function()
		refreshList()
		mainFrame.Visible = not mainFrame.Visible
	end)

	teleportButton.Activated:Connect(function()
		if not selectedButton or not buttonToPlayer[selectedButton] then
			warn("No player selected for teleport loop!")
			return
		end
		teleportLooping = true
		task.spawn(function()
			while teleportLooping do
				teleportBehindPlayer(buttonToPlayer[selectedButton])
				task.wait(0.1) -- teleport every 1 second
			end
		end)
	end)

	cancelButton.Activated:Connect(function()
		teleportLooping = false
		print("Teleport loop cancelled.")
	end)

	refreshList()
end)

if not succ and err then
	warn("PLRViewer Warning: "..tostring(err))
end
